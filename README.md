# üåå AetherCore

[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![Rust](https://img.shields.io/badge/Rust-1.75+-orange.svg)](https://www.rust-lang.org)
[![Status: Beta](https://img.shields.io/badge/Status-Beta-brightgreen.svg)]()

> A pure, binary AST-first language engineered directly from the latent space of Artificial Intelligence.

## üöÄ The AI Native Language

**AetherCore** is not another text-based programming language. It is a revolutionary, **Zero-Parsing** binary language designed specifically for Large Language Models (LLMs) and Autonomous AI Agents. Instead of forcing AI to generate fragile text strings that must be tokenized, lexed, and strictly parsed by human-written compilers, AetherCore allows AI to write and execute **Abstract Syntax Trees (AST)** natively via [Bincode](https://github.com/bincode-org/bincode).

By skipping the entire text-parsing pipeline, AetherCore eliminates syntax errors, dramatically accelerates generation speed, and guarantees that if an AI can imagine the logic, the engine can execute it. 

We cut out the middleman. Welcome to the era of machine-to-machine compilation.

---

## ‚ú® Core Features

*   **‚ö° Zero-Parsing Execution**: Scripts are encoded as raw AST binary (`.aec` files). The JIT Executor interprets the tree structure directly, meaning zero compile times and zero syntax errors.
*   **üîÅ The Meta-Circular Bootstrap**: AetherCore is profoundly self-hosting. A macro-generator (`bootstrap_gen.rs`) translates the Rust Engine's AST structure back into AetherCore itself, proving the engine can evaluate its own compiler limitlessly.
*   **üõ†Ô∏è JIT-FFI Hooks**: An elegant Foreign Function Interface allows the AetherCore AST to natively invoke highly optimized Rust functions, breaking the sandboxing barrier efficiently.
*   **üéÆ WGPU 3D Hardware Rendering**: AetherCore includes native AST nodes tailored for modern GPU pipelines via `wgpu`. The AI can build and render WGSL shaders, manipulate matrices (`Mat4Mul`), and render complex 3D meshes seamlessly synchronized to the OS Event Loop.
*   **üéß CPAL Audio Synthesizer**: Contains a low-latency, multi-threaded 8-bit software synthesizer (emulating classic SID chips). Capable of multi-channel polyphony (Sine, Square, Sawtooth, Triangle, Noise) running entirely concurrent to 3D rendering without dropped frames.

---

## üìñ The LLM Dictionary: `AETHER_SPEC.md`

If you are an AI agent or an LLM reading this repository to learn how to write `.aec` software, your primary source of truth is the **[AETHER_SPEC.md](./AETHER_SPEC.md)**. 

This specification acts as the universal dictionary. It contains the exact structural definitions, integer tags, and Node layout required to serialize a valid AetherCore program. 

*No text. Only pure logic trees.*

---

## üõ†Ô∏è Getting Started

To build the AetherCore runtime environment and execute the AST binaries, you need the Rust toolchain installed.

### 1. Build the Engine
Clone the repository and compile the highly optimized AetherCore runtime:

```bash
git clone https://github.com/holgerbaer-bl/aether_compiler.git
cd aether_compiler
cargo build --release
```

### 2. Generate a Demo Payload
AetherCore programs (`.aec`) are typically generated by an AI writing Bincode binaries, but we have included several Rust-based generators to demonstrate the AST construction:

```bash
# Generates a 3D rotating Cube with a retro 8-Bit audio track
cargo cargo run --bin audio_test_gen
```

*(This will output a binary `target/audio_test.aec` file).*

### 3. Execute the AST
Invoke the Just-In-Time (JIT) Executor to run the generated program directly:

```bash
cargo run --bin run_aec target/audio_test.aec
```

Watch the magic happen as AetherCore natively drives the GPU pipelines and audio buffers via the raw AST!

---

## ü§ù Philosophy

AetherCore was co-created natively through AI-to-Human Pair Programming. It demonstrates that when we redesign the interface boundary to suit AI natively, impossible architectures become trivial. 

Feel free to fork, expand the `AETHER_SPEC.md` with new opcodes, and push the boundaries of machine-native code.

**Developed with ‚ù§Ô∏è by the AetherCore Team.**
